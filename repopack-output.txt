================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-10-18T00:18:25.164Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
src/
  commands/
    classCommand.ts
    functionCommand.ts
  participant/
    crashifyParticipant.ts
  prompts/
    classPrompt.tsx
    functionPrompt.tsx
  services/
    languageModelService.ts
  utils/
    fileContentProvider.ts
    fileReferenceResolver.ts
    languageDetector.ts
  extension.ts
.eslintrc.json
.gitignore
.vscode-test.mjs
.vscodeignore
CHANGELOG.md
package.json
README.md
tsconfig.json
vsc-extension-quickstart.md

================================================================
Repository Files
================================================================

================
File: src/commands/classCommand.ts
================
import * as vscode from "vscode";
import { LanguageModelService } from "../services/languageModelService";
import { LanguageDetector } from "../utils/languageDetector";
import { renderPrompt } from "@vscode/prompt-tsx";
import { ClassPrompt } from "../prompts/classPrompt";

export async function handleClassCommand(
  request: vscode.ChatRequest,
  stream: vscode.ChatResponseStream,
  token: vscode.CancellationToken,
  languageDetector: LanguageDetector,
  languageModelService: LanguageModelService
) {
  const { language } = languageDetector.detect();

  try {
    const { messages } = await renderPrompt(
      ClassPrompt,
      { language, userQuery: request.prompt },
      { modelMaxPromptTokens: 4096 },
      await languageModelService.getModel()
    );

    const response = await languageModelService.sendRequest(messages, token);

    await stream.markdown(
      `Generating an example class in ${language}:`
    );

    for await (const fragment of response.text) {
      await stream.markdown(fragment);
    }

    await stream.markdown(
      "This example class demonstrates basic structure and common patterns. You can modify and extend it based on your specific needs."
    );
  } catch (err) {
    handleError(err, stream);
  }
}

function handleError(err: unknown, stream: vscode.ChatResponseStream) {
  if (err instanceof vscode.LanguageModelError) {
    console.error(err.message, err.code, err.cause);
    stream.markdown(
      "I'm sorry, I encountered an error while generating the example class. Please try again or provide more specific requirements."
    );
  } else {
    throw err;
  }
}

================
File: src/commands/functionCommand.ts
================
import * as vscode from "vscode";
import { LanguageModelService } from "../services/languageModelService";
import { LanguageDetector } from "../utils/languageDetector";
import { renderPrompt } from "@vscode/prompt-tsx";
import { FunctionPrompt } from "../prompts/functionPrompt";

export async function handleFunctionCommand(
  request: vscode.ChatRequest,
  stream: vscode.ChatResponseStream,
  token: vscode.CancellationToken,
  languageDetector: LanguageDetector,
  languageModelService: LanguageModelService
) {
  const { language } = languageDetector.detect();

  try {
    const { messages } = await renderPrompt(
      FunctionPrompt,
      { language, userQuery: request.prompt },
      { modelMaxPromptTokens: 4096 },
      await languageModelService.getModel()
    );

    const response = await languageModelService.sendRequest(messages, token);

    await stream.markdown(
      `Generating an example function in ${language}:`
    );

    for await (const fragment of response.text) {
      await stream.markdown(fragment);
    }

    await stream.markdown(
      "This example function demonstrates basic structure and common patterns. You can modify and extend it based on your specific needs."
    );
  } catch (err) {
    handleError(err, stream);
  }
}

function handleError(err: unknown, stream: vscode.ChatResponseStream) {
  if (err instanceof vscode.LanguageModelError) {
    console.error(err.message, err.code, err.cause);
    stream.markdown(
      "I'm sorry, I encountered an error while generating the example function. Please try again or provide more specific requirements."
    );
  } else {
    throw err;
  }
}

================
File: src/participant/crashifyParticipant.ts
================
import * as vscode from "vscode";
import { LanguageModelService } from "../services/languageModelService";
import { LanguageDetector } from "../utils/languageDetector";
import { FileContentProvider } from "../utils/fileContentProvider";
import { handleClassCommand } from "../commands/classCommand";
import { handleFunctionCommand } from "../commands/functionCommand";

export class CrashifyParticipant {
  private fileContentProvider: FileContentProvider;

  constructor(
    private languageDetector: LanguageDetector,
    private languageModelService: LanguageModelService
  ) {
    this.fileContentProvider = new FileContentProvider();
  }

  async handleRequest(
    request: vscode.ChatRequest,
    context: vscode.ChatContext,
    stream: vscode.ChatResponseStream,
    token: vscode.CancellationToken
  ) {
    switch (request.command) {
      case "class":
        await handleClassCommand(
          request,
          stream,
          token,
          this.languageDetector,
          this.languageModelService
        );
        break;
        case "function":
          await handleFunctionCommand(
            request,
            stream,
            token,
            this.languageDetector,
            this.languageModelService
          );
          break;  
      default:
        await this.handleGeneralRequest(request, stream, token);
    }
  }

  private async handleGeneralRequest(
    request: vscode.ChatRequest,
    stream: vscode.ChatResponseStream,
    token: vscode.CancellationToken
  ) {
    const prompt = [
      vscode.LanguageModelChatMessage.User(
        "You are Crashify, an AI assistant specializing in debugging and crash analysis tasks. Respond to queries about error handling, debugging techniques, and crash report analysis."
      ),
      vscode.LanguageModelChatMessage.User(request.prompt),
    ];

    try {
      const response = await this.languageModelService.sendRequest(
        prompt,
        token
      );

      for await (const fragment of response.text) {
        await stream.markdown(fragment);
      }

      await stream.markdown(
        "You can use the following commands:\n" +
          "- `/list`: Generate a list of common crash causes\n" +
          "- `/model`: Create an error model (usage: `/model ErrorName [description]`)\n" +
          "- `/json`: Generate a sample crash report JSON based on the current file content\n" +
          "- `/get`: Retrieve specific error information"
      );
    } catch (err) {
      this.handleError(err, stream);
    }
  }

  private handleError(err: unknown, stream: vscode.ChatResponseStream) {
    if (err instanceof vscode.LanguageModelError) {
      console.error(err.message, err.code, err.cause);
      stream.markdown(
        "I apologize, but I encountered an error while processing your request. This might be related to the crash you're investigating. Can you provide more details or try rephrasing your query?"
      );
    } else {
      throw err;
    }
  }
}

================
File: src/prompts/classPrompt.tsx
================
import {
    BasePromptElementProps,
    PromptElement,
    PromptSizing,
    AssistantMessage,
    UserMessage,
  } from "@vscode/prompt-tsx";
  
  export interface ClassPromptProps extends BasePromptElementProps {
    language: string;
    userQuery: string;
  }
  
  export class ClassPrompt extends PromptElement<ClassPromptProps> {
    render(_state: void, _sizing: PromptSizing) {
      return (
        <>
          <AssistantMessage>You are an expert in object-oriented programming and software design.</AssistantMessage>
          <UserMessage>
            Generate an example class in {this.props.language}.
            <br />
            Include the following in your response:
            <br />
            1. A complete, working example of a class with common features like constructor, properties, methods, and if applicable, inheritance or interfaces.
            <br />
            2. Brief explanations of key concepts and best practices related to classes in this language.
            <br />
            3. Examples of how to instantiate and use the class.
            <br />
            4. Any language-specific considerations for working with classes.
            <br />
            User's specific request (if any): {this.props.userQuery}
          </UserMessage>
        </>
      );
    }
  }

================
File: src/prompts/functionPrompt.tsx
================
import {
    BasePromptElementProps,
    PromptElement,
    PromptSizing,
    AssistantMessage,
    UserMessage,
  } from "@vscode/prompt-tsx";
  
  export interface FunctionPromptProps extends BasePromptElementProps {
    language: string;
    userQuery: string;
  }
  
  export class FunctionPrompt extends PromptElement<FunctionPromptProps> {
    render(_state: void, _sizing: PromptSizing) {
      return (
        <>
          <AssistantMessage>You are an expert in programming and software design.</AssistantMessage>
          <UserMessage>
            Generate an example function in {this.props.language}.
            <br />
            Include the following in your response:
            <br />
            1. A complete, working example of a function with parameters, return type (if applicable), and a meaningful implementation.
            <br />
            2. Brief explanations of key concepts and best practices related to functions in this language.
            <br />
            3. Examples of how to call and use the function.
            <br />
            4. Any language-specific considerations for working with functions.
            <br />
            User's specific request (if any): {this.props.userQuery}
          </UserMessage>
        </>
      );
    }
  }

================
File: src/services/languageModelService.ts
================
import * as vscode from "vscode";

export class LanguageModelService {
  private model: vscode.LanguageModelChat | null = null;

  async getModel(): Promise<vscode.LanguageModelChat> {
    if (!this.model) {
      const [model] = await vscode.lm.selectChatModels({
        vendor: "copilot",
        family: "gpt-4o",
      });
      this.model = model;
    }
    return this.model;
  }

  async sendRequest(
    prompt: vscode.LanguageModelChatMessage[],
    token: vscode.CancellationToken
  ): Promise<vscode.LanguageModelChatResponse> {
    const model = await this.getModel();
    return model.sendRequest(prompt, {}, token);
  }
}

================
File: src/utils/fileContentProvider.ts
================
import * as vscode from 'vscode';

export class FileContentProvider {
    async getActiveFileContent(): Promise<string | undefined> {
        const activeEditor = vscode.window.activeTextEditor;
        if (activeEditor) {
            const document = activeEditor.document;
            return document.getText();
        }
        return undefined;
    }
}

================
File: src/utils/fileReferenceResolver.ts
================
import * as vscode from "vscode";

export class FileReferenceResolver {
  async resolveFileReferences(
    request: vscode.ChatRequest
  ): Promise<Map<string, string>> {
    const fileContents = new Map<string, string>();

    for (const reference of request.references) {
      if (reference.id === "vscode.file") {
        if (reference.value === undefined || reference.value === null) {
          continue;
        }

        try {
          const fileUri = vscode.Uri.parse(reference.value.toString());
          const fileContent = await this.readFileContent(fileUri);
          fileContents.set(reference.id, fileContent);
        } catch (error) {
          console.error(`Error reading file ${reference.id}: ${error}`);
        }
      }
    }

    return fileContents;
  }

  private async readFileContent(uri: vscode.Uri): Promise<string> {
    const readData = await vscode.workspace.fs.readFile(uri);
    return new TextDecoder().decode(readData);
  }
}

================
File: src/utils/languageDetector.ts
================
import * as vscode from "vscode";

export class LanguageDetector {
  detect(): { language: string } {
    const activeEditor = vscode.window.activeTextEditor;
    let language = "Not detected";

    if (activeEditor) {
      language = activeEditor.document.languageId;
    }

    return { language };
  }
}

================
File: src/extension.ts
================
import * as vscode from "vscode";
import { LanguageDetector } from "./utils/languageDetector";
import { LanguageModelService } from "./services/languageModelService";
import { CrashifyParticipant } from "./participant/crashifyParticipant";

export function activate(context: vscode.ExtensionContext) {
  const languageDetector = new LanguageDetector();
  const languageModelService = new LanguageModelService();

  const crashify = new CrashifyParticipant(languageDetector, languageModelService);

  context.subscriptions.push(
    vscode.chat.createChatParticipant(
      "crashify-chat-extension.crashify",
      crashify.handleRequest.bind(crashify)
    )
  );
}

export function deactivate() {}

================
File: .eslintrc.json
================
{
    "root": true,
    "parser": "@typescript-eslint/parser",
    "parserOptions": {
        "ecmaVersion": 6,
        "sourceType": "module"
    },
    "plugins": [
        "@typescript-eslint"
    ],
    "rules": {
        "@typescript-eslint/naming-convention": [
            "warn",
            {
                "selector": "import",
                "format": [ "camelCase", "PascalCase" ]
            }
        ],
        "@typescript-eslint/semi": "warn",
        "curly": "warn",
        "eqeqeq": "warn",
        "no-throw-literal": "warn",
        "semi": "off"
    },
    "ignorePatterns": [
        "out",
        "dist",
        "**/*.d.ts"
    ]
}

================
File: .gitignore
================
out
dist
node_modules
.vscode-test/
*.vsix

================
File: .vscode-test.mjs
================
import { defineConfig } from '@vscode/test-cli';

export default defineConfig({
	files: 'out/test/**/*.test.js',
});

================
File: .vscodeignore
================
.vscode/**
.vscode-test/**
src/**
.gitignore
.yarnrc
vsc-extension-quickstart.md
**/tsconfig.json
**/.eslintrc.json
**/*.map
**/*.ts
**/.vscode-test.*

================
File: CHANGELOG.md
================
# Change Log

All notable changes to the "crashify" extension will be documented in this file.

Check [Keep a Changelog](http://keepachangelog.com/) for recommendations on how to structure this file.

## [Unreleased]

- Initial release

================
File: package.json
================
{
  "name": "crashify-chat-extension",
  "displayName": "Crashify Chat Extension",
  "description": "Code in every language",
  "version": "0.0.1",
  "engines": {
    "vscode": "^1.85.0"
  },
  "categories": [
    "AI",
    "Chat",
    "Debuggers"
  ],
  "activationEvents": [],
  "main": "./out/extension.js",
  "contributes": {
    "chatParticipants": [
      {
        "id": "crashify-chat-extension.crashify",
        "name": "crashify",
        "fullName": "Crashify",
        "description": "Crashify assistant for debugging and crash analysis tasks",
        "commands": [
          {
            "name": "class",
            "description": "Generate a class in the current language"
          },
          {
            "name": "function",
            "description": "Generate a function in the current language"
          }
        ]
      }
    ]
  },
  "scripts": {
    "vscode:prepublish": "npm run compile",
    "compile": "tsc -p ./",
    "lint": "eslint src --ext ts",
    "watch": "tsc -watch -p ./"
  },
  "devDependencies": {
    "@types/node": "16.x",
    "@types/vscode": "^1.85.0",
    "@typescript-eslint/eslint-plugin": "^6.7.0",
    "@typescript-eslint/parser": "^6.7.0",
    "eslint": "^8.44.0",
    "typescript": "^5.2.2"
  },
  "dependencies": {
    "@vscode/prompt-tsx": "^0.2.11-alpha"
  }
}

================
File: README.md
================
# crashify README

This is the README for your extension "crashify". After writing up a brief description, we recommend including the following sections.

## Features

Describe specific features of your extension including screenshots of your extension in action. Image paths are relative to this README file.

For example if there is an image subfolder under your extension project workspace:

\!\[feature X\]\(images/feature-x.png\)

> Tip: Many popular extensions utilize animations. This is an excellent way to show off your extension! We recommend short, focused animations that are easy to follow.

## Requirements

If you have any requirements or dependencies, add a section describing those and how to install and configure them.

## Extension Settings

Include if your extension adds any VS Code settings through the `contributes.configuration` extension point.

For example:

This extension contributes the following settings:

* `myExtension.enable`: Enable/disable this extension.
* `myExtension.thing`: Set to `blah` to do something.

## Known Issues

Calling out known issues can help limit users opening duplicate issues against your extension.

## Release Notes

Users appreciate release notes as you update your extension.

### 1.0.0

Initial release of ...

### 1.0.1

Fixed issue #.

### 1.1.0

Added features X, Y, and Z.

---

## Following extension guidelines

Ensure that you've read through the extensions guidelines and follow the best practices for creating your extension.

* [Extension Guidelines](https://code.visualstudio.com/api/references/extension-guidelines)

## Working with Markdown

You can author your README using Visual Studio Code. Here are some useful editor keyboard shortcuts:

* Split the editor (`Cmd+\` on macOS or `Ctrl+\` on Windows and Linux).
* Toggle preview (`Shift+Cmd+V` on macOS or `Shift+Ctrl+V` on Windows and Linux).
* Press `Ctrl+Space` (Windows, Linux, macOS) to see a list of Markdown snippets.

## For more information

* [Visual Studio Code's Markdown Support](http://code.visualstudio.com/docs/languages/markdown)
* [Markdown Syntax Reference](https://help.github.com/articles/markdown-basics/)

**Enjoy!**

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "module": "Node16",
    "target": "ES2022",
    "outDir": "out",
    "lib": ["ES2022"],
    "sourceMap": true,
    "rootDir": "src",
    "strict": true /* enable all strict type-checking options */,
    "jsx": "react",
    "jsxFactory": "vscpp",
    "jsxFragmentFactory": "vscppf"
    /* Additional Checks */
    // "noImplicitReturns": true, /* Report error when not all code paths in function return a value. */
    // "noFallthroughCasesInSwitch": true, /* Report errors for fallthrough cases in switch statement. */
    // "noUnusedParameters": true,  /* Report errors on unused parameters. */
  }
}

================
File: vsc-extension-quickstart.md
================
# Welcome to your VS Code Extension

## What's in the folder

* This folder contains all of the files necessary for your extension.
* `package.json` - this is the manifest file in which you declare your extension and command.
  * The sample plugin registers a command and defines its title and command name. With this information VS Code can show the command in the command palette. It doesn’t yet need to load the plugin.
* `src/extension.ts` - this is the main file where you will provide the implementation of your command.
  * The file exports one function, `activate`, which is called the very first time your extension is activated (in this case by executing the command). Inside the `activate` function we call `registerCommand`.
  * We pass the function containing the implementation of the command as the second parameter to `registerCommand`.

## Get up and running straight away

* Press `F5` to open a new window with your extension loaded.
* Run your command from the command palette by pressing (`Ctrl+Shift+P` or `Cmd+Shift+P` on Mac) and typing `Hello World`.
* Set breakpoints in your code inside `src/extension.ts` to debug your extension.
* Find output from your extension in the debug console.

## Make changes

* You can relaunch the extension from the debug toolbar after changing code in `src/extension.ts`.
* You can also reload (`Ctrl+R` or `Cmd+R` on Mac) the VS Code window with your extension to load your changes.

## Explore the API

* You can open the full set of our API when you open the file `node_modules/@types/vscode/index.d.ts`.

## Run tests

* Install the [Extension Test Runner](https://marketplace.visualstudio.com/items?itemName=ms-vscode.extension-test-runner)
* Run the "watch" task via the **Tasks: Run Task** command. Make sure this is running, or tests might not be discovered.
* Open the Testing view from the activity bar and click the Run Test" button, or use the hotkey `Ctrl/Cmd + ; A`
* See the output of the test result in the Test Results view.
* Make changes to `src/test/extension.test.ts` or create new test files inside the `test` folder.
  * The provided test runner will only consider files matching the name pattern `**.test.ts`.
  * You can create folders inside the `test` folder to structure your tests any way you want.

## Go further

* [Follow UX guidelines](https://code.visualstudio.com/api/ux-guidelines/overview) to create extensions that seamlessly integrate with VS Code's native interface and patterns.
* Reduce the extension size and improve the startup time by [bundling your extension](https://code.visualstudio.com/api/working-with-extensions/bundling-extension).
* [Publish your extension](https://code.visualstudio.com/api/working-with-extensions/publishing-extension) on the VS Code extension marketplace.
* Automate builds by setting up [Continuous Integration](https://code.visualstudio.com/api/working-with-extensions/continuous-integration).
